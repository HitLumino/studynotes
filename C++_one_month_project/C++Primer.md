# C++ Primer

**路漫漫其修远兮，吾将上下而求索。----2018.4.28 夜**



## 第二章 变量和基本类型

### 当我们付给带符号类型一个超出他的范围的值时，结果是未定义的。（p33）
### 左值和右值
* **左值可以出现在赋值语句的左边或右边。**
* 右值只能出现在赋值的右边，不能出现在赋值语句的左边。
变量是左值，因此可以出现在赋值语句的左边。数字字面值是右值，因此不能被赋值。
### 声明和定义
* 变量的定义用于为变量分配存储空间，还可以为变量指定初始值。在一个程序中，变量有且仅有一个定义。
* 声明用于向程序表明变量的类型和名字。定义也是声明：当定义变量时我们声明了它的类型和名字。可以通过使用 extern 关键字声明变量名而不定义它。不定义变量的声明包括对象名、对象类型和对象类型前的关键字`extern`
    ```c
    extern int i; // declares but does not define i
    int i; // declares and defines i
    ```
* extern 声明不是定义，也不分配存储空间。事实上，它只是说明变量定义在程序的其他地方。程序中变量可以声明多次，但只能定义一次。
### 引用和const和指针
* 当引用初始化后，只要该引用存在，它就保持绑定到初始化时指向的对象。不可能将引用再绑定到另一个对象。
* 空指针：生成空指针：`int p=nullptr`
* `void*`:可以存放任意对象的地址，但是我们不知道是什么样的类型的对象。
* 指向指针的引用。
    ```c
    int i=42;
    int *p;
    int *&r=p;

    r=&i;//相当于p指向i
    *r=0;
    ```
要理解r到底是什么，最简单的办法是从右向左阅读r的定义。因此上一个r是一个引用。应用的是一个指针，最后数据类型是int。
* `constexpr`:常量表达式是指值不会改变并且在编译过程中就能得到结果。
    ```c++
    constexpr int mf=20;//20是常量表达式
    constexpr int limit=mf+1;
    constexpr int sz=size(); //只有当size()是constexpr函数时，才正确！
    ```
* 如果你认为变量是一个常量表达式，那就把它声明为`constexpr`.

### 类型别名`typedef`和`using`
 `typedef double wages;` 
 `using SI=Sale_Item;`

## 搞清楚什么是拷贝/移动构造函数?

拷贝控制操作:5种.

拷贝构造函数/拷贝赋值运算符/移动构造函数/移动赋值运算符/析构函数

### 什么是拷贝? 深拷贝? 浅拷贝?　

* 如果一个构造函数的第一个参数是自身类型的引用，且任何额外参数都有默认值，那么这就是拷贝构造函数．
* 如果一个类有一个移动构造函数，则拷贝初始化有时会使用移动构造函数而非拷贝构造函数来完成.
* **拷贝初始化**不仅在`=``定义变量时发生,在以下情况也会发生:(P441)
    * 将一个对象作为实参传递给一个非引用类型的形参  (传值)
    * 从一个返回类型为非引用类型的函数返回一个对象  (不是返回引用)
    * 用花括号列表初始化一个数组中的一个元素或一个聚合类中的成员
    * 当我们初始化STL容器或者调用`insert`或`push`成员时,也是拷贝初始化.相反,用`emplace`成员创建的元素都进行直接初始化.[1]
    
#### [1]Notes: 对比`push`和`emplace`成员函数.

* 向一个`vector deque string `插入元素会使所有指向容器的迭代器/引用和指针失效.(effective STL)
* 向一个`vector deque string `尾部以外插入元素,都需要移动元素;向`vector string`添加元素可能会导致整个对象存储空间的**重新分配**.(effective STL)
* 当我们用一个对象来初始化容器,或插入.实际放入容器的是对象值的拷贝,而不是对象本身.

`emplace`操作: `emplace_front`/ `emplace`/ `emplace_back`

当我们调用一个`emplace`成员函数时,直接将参数传递给元素类型的构造函数.`emplace`成员直接在容器管理的内存空间中直接构造元素.

```c
c.emplace_back("99-99",25,15.99);//直接构造sales_data对象     1
c.push_back("99-99",25,15.99);//错误!,不符合`push_back`参数   2
c.push_back(sales_data("99-99",25,15.99));//创建一个临时对象,在传递给push_back    3
```
其中 1,3 都会创建新的sales_data对象,在1中会直接在容器管理的内存空间中创建对象.而3 会创建临时对象,再压入容器中.

```c
c.emplace_back();//使用sales_data默认构造函数
c.emplace(iter,"99-99");//使用相对应的构造函数
```

Notes: 传递给emplace函数的参数必须与元素类型的构造函数相匹配.