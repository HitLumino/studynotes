#### 环境配置篇

* [sublime+cmder](https://blog.csdn.net/whqet/article/details/50259677)
* VS编译`winsock2.h`的时候，需要加上`#pragma comment(lib,"ws2_32.lib")`
  * gcc编译需要`gcc xxx.c -o xxx -lws2_32`
* [windows 编译openssl](https://blog.csdn.net/liang19890820/article/details/51658574)
  
#### 网络编程

##### [原子操作](https://www.jianshu.com/p/121ec513f1e6)
> 线程1和2都执行了+1运算，本来我们期望得到102，但却错误的得到了101这个值。
从上面这个引起错误的流程可以看出，之所以结果错误，其本质是两个线程同时操作了同一个对象，线程1执行++运算的过程中插入了线程2的++操作，也就是说从另外一    个线程的角度看++操作并不是一个原子操作。
现在我们已经知道多线程并发执行counter++其结果并不正确的原因了，但怎么解决这个问题呢？既然错误是因为++不是一个原子操作，那么我们想办法使其成为原子操    作就可以了，所以我们可以：1，加锁，2，使用原子变量。
* 加锁导致性能下降很大。
* 使用原子操作原子变量，可以不用加锁，就可以实现两个线程对同一个变量累加操作。

##### getpwnam函数学习
* [getpwnam函数学习](https://blog.csdn.net/wallwind/article/details/7781314)

##### 线程池
* [C++ 并发编程（四）：基于 Boost Thread 和 Asio 的线程池](https://segmentfault.com/a/1190000006691692)
* [浅谈 Boost.Asio 的多线程模型](http://senlinzhan.github.io/2017/09/17/boost-asio/)

##### shared_ptr
* [谈谈 shared_ptr 的那些坑](http://senlinzhan.github.io/2015/04/24/%E6%B7%B1%E5%85%A5shared-ptr/)

   + `group.push_back( shared_from_this() );`
   + 为什么会有`weak_ptr`？
 
##### SSL

> 执行 CipherSuite 的认证和协商时，SSL/TLS 客户机和服务器之间的初始连接请求期间发生 SSL/TLS 握手过程。
如果你看到HTTPS字样和/或浏览器地址栏的挂锁图标，那么你和网站之间的安全连接就是由SSL/TLS建立的。

客户端也会得到服务器拥有与此证书相关的私钥的证明。所有SSL证书都包含一对密钥，密匙由一个公钥和一个私钥组成。公钥用于加密数据，私钥则用于解密。这称为“不对称”加密，因为两个功能由不同的密钥来执行。

就最常见的密钥类型RSA来说，客户端会以公钥加密随机数据，用该公钥生成会话密钥。只有当服务器有私钥提供所有权证明的情况下，才能解密并使用该数据。如果使用另一类型的密钥，这个过程就变了，但总是需要检验所有权证明的。


* [浏览器、HTTP、SSL、HTTPS执行流程](https://www.jianshu.com/p/c2bf75485c15)
* [【科普】SSL握手](https://www.sslchina.com/ssl-handshake/)

##### DTLS
* [Get the DTLS echo client/server code.](http://sctp.fh-muenster.de/dtls-samples.html)

##### 加密算法分类
* [常见加密算法分,用途,原理以及比较](https://blog.csdn.net/zuiyuezhou888/article/details/7557048)

根据密钥类型不同将现代密码技术分为两类：对称加密算法（秘密钥匙加密）和非对称加密算法（公开密钥加密）。

   * 对称钥匙加密系统是加密和解密均采用同一把秘密钥匙，而且通信双方都必须获得这把钥匙，并保持钥匙的秘密。
   * 非对称密钥加密系统采用的加密钥匙（公钥）和解密钥匙（私钥）是不同的。
   * 散列算法 MD5 SHA-2
